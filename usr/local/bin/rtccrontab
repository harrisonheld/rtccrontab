#!/usr/bin/env python3

import os
import sys
import shutil
import tempfile
import subprocess
from datetime import datetime, timedelta
import argparse
import logging

try:
    from croniter import croniter
except ImportError:
    print("croniter module missing. Install with: pip install croniter")
    sys.exit(1)

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
)
logger = logging.getLogger("rtccrontab")

# Default configuration
CONFIG_FILE = "/etc/rtccrontab.conf"
EDITOR = os.getenv("EDITOR", "vi")
WAKE_OFFSET_MIN = 5
BASE_DIR = os.path.expanduser("~/.rtccrontab")

# Derived paths (will be recomputed after config load)
SRC_FILE = os.path.join(BASE_DIR, "rtccrontab")
JOB_DIR = os.path.join(BASE_DIR, "jobs")
CRON_D_FILE = f"/etc/cron.d/rtccrontab-{os.getenv('USER')}"

def load_config():
    """Load configuration from /etc/rtccrontab.conf"""
    global WAKE_OFFSET_MIN, BASE_DIR, SRC_FILE, JOB_DIR, CRON_D_FILE
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE) as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#") or "=" not in line:
                    continue
                key, value = line.split("=", 1)
                key = key.strip()
                value = value.strip()
                if key == "WAKE_OFFSET_MIN":
                    try:
                        WAKE_OFFSET_MIN = int(value)
                        logger.debug(f"Loaded WAKE_OFFSET_MIN={WAKE_OFFSET_MIN} from config")
                    except ValueError:
                        logger.warning(f"Ignoring invalid WAKE_OFFSET_MIN in config: {value}")
                elif key == "BASE_DIR":
                    BASE_DIR = os.path.expandvars(os.path.expanduser(value))
                    logger.debug(f"Loaded BASE_DIR={BASE_DIR} from config")

    SRC_FILE = os.path.join(BASE_DIR, "rtccrontab")
    JOB_DIR = os.path.join(BASE_DIR, "jobs")
    CRON_D_FILE = f"/etc/cron.d/rtccrontab-{os.getenv('USER')}"


def ensure_dirs():
    os.makedirs(JOB_DIR, exist_ok=True)
    os.makedirs(BASE_DIR, exist_ok=True)
    logger.debug(f"Ensured directories exist: {BASE_DIR}, {JOB_DIR}")


def list_crontab():
    if not os.path.exists(SRC_FILE):
        logger.warning("No rtccrontab file found.")
        return
    with open(SRC_FILE) as f:
        print(f.read(), end="")


def remove_crontab():
    logger.info("Removing rtccrontab and jobs")
    if os.path.exists(SRC_FILE):
        os.remove(SRC_FILE)
    if os.path.exists(JOB_DIR):
        shutil.rmtree(JOB_DIR)
    if os.path.exists(CRON_D_FILE):
        try:
            subprocess.run(["sudo", "rm", "-f", CRON_D_FILE], check=True, stdout=subprocess.DEVNULL)
        except subprocess.CalledProcessError:
            logger.error("Failed to remove system cron file.")
    try:
        subprocess.run(["sudo", "rtcwake", "-m", "disable"], check=True, stdout=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        logger.error("Failed to disable rtcwake.")
    logger.info("rtccrontab removed and rtcwake unset.")


def edit_crontab():
    logger.info(f"Editing rtccrontab: {SRC_FILE}")
    if not os.path.exists(SRC_FILE):
        open(SRC_FILE, "w").close()
    tmp = tempfile.NamedTemporaryFile(delete=False)
    shutil.copy(SRC_FILE, tmp.name)
    subprocess.run([EDITOR, tmp.name])
    shutil.copy(tmp.name, SRC_FILE)
    os.unlink(tmp.name)
    generate_jobs()
    schedule_next_wake()


def generate_jobs():
    logger.debug("Generating job scripts")

    # Clean old jobs
    for f in os.listdir(JOB_DIR):
        os.remove(os.path.join(JOB_DIR, f))

    if not os.path.exists(SRC_FILE):
        logger.warning("No rtccrontab file found, skipping job generation")
        return

    with open(SRC_FILE) as f:
        lines = [l.strip() for l in f if l.strip() and not l.startswith("#")]

    cron_lines = []

    for i, line in enumerate(lines, start=1):
        parts = line.split()
        if len(parts) < 6:
            logger.warning(f"Skipping invalid line {i}: {line}")
            continue
        schedule = " ".join(parts[:5])
        command = " ".join(parts[5:])
        job_script_path = os.path.join(JOB_DIR, f"job{i}.sh")

        with open(job_script_path, "w") as js:
            js.write(f"""#!/bin/bash
# DO NOT EDIT
# Job {i} wrapper generated by rtccrontab

# Run the original command
{command}

# Recompute next wake
{SRC_FILE} -w
""")
        os.chmod(job_script_path, 0o755)
        cron_lines.append(f"{schedule} {os.getenv('USER')} {job_script_path}")

    if cron_lines:
        cron_content = "\n".join(cron_lines) + "\n"
        tmp_cron = tempfile.NamedTemporaryFile(delete=False)
        tmp_cron.write(cron_content.encode())
        tmp_cron.close()
        try:
            subprocess.run(["sudo", "mv", tmp_cron.name, CRON_D_FILE], check=True)
            subprocess.run(["sudo", "chmod", "644", CRON_D_FILE], check=True)
            subprocess.run(["sudo", "chown", "root:root", CRON_D_FILE], check=True)
            logger.info(f"Installed {len(cron_lines)} jobs to {CRON_D_FILE}")
        except subprocess.CalledProcessError:
            logger.error("Failed to write system cron. Run with sudo.")
            os.unlink(tmp_cron.name)


def schedule_next_wake():
    """Initial wake setup after generating jobs"""
    if not os.path.exists(SRC_FILE):
        return

    next_times = []
    with open(SRC_FILE) as f:
        lines = [l.strip() for l in f if l.strip() and not l.startswith("#")]

    for line in lines:
        parts = line.split()
        if len(parts) < 6:
            continue
        schedule = " ".join(parts[:5])
        it = croniter(schedule, datetime.now())
        nxt = it.get_next(datetime) - timedelta(minutes=WAKE_OFFSET_MIN)
        next_times.append(int(nxt.timestamp()))

    if next_times:
        earliest_waketime = min(next_times)
        try:
            subprocess.run(["sudo", "rtcwake", "-m", "no", "-t", str(earliest_waketime)], check=True, stdout=subprocess.DEVNULL)
            logger.info(f"Scheduled next wake at {datetime.fromtimestamp(earliest_waketime)}")
        except subprocess.CalledProcessError:
            logger.error("Failed to set rtcwake.")


def check_capabilities():
    """Check RTC and rtcwake capabilities on the system"""
    all_good = True

    # Check if rtcwake is installed
    rtcwake_path = shutil.which("rtcwake")
    if not rtcwake_path:
        logger.error("❌ rtcwake not found in PATH")
        all_good = False
    else:
        logger.info(f"✅ rtcwake found at: {rtcwake_path}")

    # Check available RTC devices
    try:
        rtc_devices = [f for f in os.listdir("/dev") if f.startswith("rtc")]
    except Exception as e:
        rtc_devices = []
        logger.error(f"❌ Failed to list /dev: {e}")
        all_good = False

    if rtc_devices:
        logger.info(f"✅ Found RTC devices: {', '.join(rtc_devices)}")
    else:
        logger.error("❌ No RTC devices found under /dev")
        all_good = False

    # Final summary
    if all_good:
        logger.info("\n✅ System is ready for rtccrontab")
    else:
        logger.warning("\n❌ System is not ready for rtccrontab; missing components above")


def main():
    parser = argparse.ArgumentParser(
        description=(
            "rtccrontab - Cron replacement with automatic rtcwake before jobs. Keeps its own crontab.\n\n"
            "Configuration can be set in /etc/rtccrontab.conf:\n"
            "  - BASE_DIR: location of user rtccrontab (~ expansion and $USER supported)\n"
            "  - WAKE_OFFSET_MIN: minutes before job to wake the system"
        ),
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("-e", action="store_true", help="edit rtccrontab")
    parser.add_argument("-l", action="store_true", help="list rtccrontab")
    parser.add_argument("-r", action="store_true", help="remove rtccrontab")
    parser.add_argument("-w", action="store_true", help="schedule next wake")
    parser.add_argument("-c", "--check", action="store_true", help="check system RTC/rtcwake capabilities")
    parser.add_argument("-v", "--verbose", action="store_true", help="enable verbose logging")
    args = parser.parse_args()

    if args.verbose:
        logger.setLevel(logging.DEBUG)

    load_config()
    ensure_dirs()

    if args.l:
        list_crontab()
    elif args.r:
        remove_crontab()
    elif args.e:
        edit_crontab()
    elif args.w:
        schedule_next_wake()
    elif args.check:
        check_capabilities()
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
